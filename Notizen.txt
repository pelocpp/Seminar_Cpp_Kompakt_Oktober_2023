C++ Kompakt
===========

Christian // Felix (Remote)

Peter Loos

peter.loos@gmx.de

C/C++,  C#, Java, JavaScript, Mobile Programming (Java)

Back to the Roots: C++

Vorraussetzungen:

ST // Structured Text   

C#

====================================

Tools:

i) Visual Studio 

ii) Github.com

====================================

3. Tag:

== ++ Operator

== Ein-/Ausgabe (Operator <<)

== Namensräume

== OO an einem realen Beispiel: Klasse std::string

== Vererbung

== Standard-Bibliothek

====================================

Getting Started:

===> "Hello World"

===> OO  // Objekt Orientierung

====================================

C++:

Editor  ==> Quelltext verfassen

Tool:   a) Überprüft den Quelltext (Syntax):   Compiler // Übersetzer

        b) Wenn alles Okay: Wird Maschinencode erzeugt.

        zB

        C:\Peter_Loos\Cpp_Kompakt\x64\Debug\Cpp_Kompakt.exe

        Eine Datei mit der Endung .exe: Das ist Maschinencode

Wie wird das Programm ausgeführt?

i)   Mit dem Windows Datei Explorer (Doppelclick)

ii)  In einer Windows Konsole

iii) Mit dem Visual Studio:   Debuggen => Starten ohne Debuggen



Syntax: Grammatik  // Satzbau 

====================================

Jedes C/C++ - Programm hat einen Einsprungpunkt // Startpunkt:

Unterprogramm mit Namen 'main'

====================================

ToDo - Liste:

== Namensräume

====================================

Bemerkungen zu "Hello World"

== C/C++: Format - freie Sprache 

== Wozu "return 1;"   

   Ist eher für "Skript"-Programmierung: Skripte, die mit dem Betriebssystem interagieren

      // Linux: Shell-Programmierung
      // Windows: Power Shell

====================================

Variablen und Datentypen:

	short s;       // 2 bytes           maximal 32.767
	int n;         // 4 bytes           maximal 2.147.483.647
	long l;        // 4 oder 8 bytes
	long long ll;  // 8 bytes

Frage:

Meine Werte, die ich verarbeiten möchte, sind im Bereich von 0 bis 999.

Welchen Datentyp für meine Variablen verwende ich ?

a) Man nimmt short

b) Wir haben genügend Speicher ==> int

i)  "Man nimmt short":  Die CPU (Recheneinheit) kennt weder short noch int:

                        Sie arbeitet mit einem Akku (Akkumulator) // Register

                        Hat eine Breite (Bits) - entspricht im Regelfall 'int'

    Fazit: Für "einzelne" Variablen würde ich für 'int' gehen

ii) Ich muss eine Messreihe mit 1.000.000 Daten verarbeiten / auswerten:

    Ein Feld // Array: Unterschied:  Feld mit einer Million Variablen vom Typ short

                                     Feld mit einer Million Variablen vom Typ int

    Fazit: Für "viele" Variablen würde ich für 'short' gehen


===========================================================

Begriff: struct

== Array:      Viele Daten desselben Typs (Messreihe)

== Struktur:   Ist ein Oberbegriff für viele Daten, in der Regel unterschiedlichen Typs 

   Beispiel:   Student:   Namen (Zeichenkette),
                          Alter (int)
                          Wohnort (Zeichenkette)
                          PLZ   (int)

   Beispiel:   Uhrzeit    Stunden, Minuten, Sekunden


Begriff: struct  ====>  Vorbereitung: Objekt-Orientierung

==========================================================

Wie lange leben Variablen ???

Welche Lebenszeit haben Variablen ???

a) Globale Variablen:

   Gelten für die gesamte Laufzeit des Programms.

   Vereinbarung: Auf der "obersten Ebene" (top-level) des Programms.

   Sind überall verwendbar.

b) Lokale Variablen:

   Gelten für die Ausführungszeit eines Unterprogramms.

   "Das ist nicht sehr viel"

   ==> Sind eher für Zwischenergebnisse geeignet

   ==> Können aber als Parameter an andere Unterprogramme weitergereicht werden

c) Dynamisch allokierte Variablen

   new // malloc

   Leben vom Aufruf von new bis zur Zerstörung (delete // free)

======================================================

Was ist ein Unterprogramm:

Fasst eine Reihe von Anweisungen unter einem NAMEN zusammen:

void ausgabe()
{
	std::cout << "Dies ist ein C++ Kompakt Seminar";
}

Name: ausgabe

Was bedeutet 'void': void steht für "nichts"
Dieses Unterprogramm hat KEIN Ergebnis.

Wozu die Klammern () ?

Sind für Parameter: 

Was ist ein Parameter: Ist ein Stellvertreter für einen realen Wert.


Ein Unterprogramm kann ein Ergebnis haben oder auch nicht:

Nomenklatur // Sprechweise:

Unterprogramm ohne Ergebnis: Prozedur

    Umsetzung in C++: void als Rückgabetyp

Unterprogramm mit Ergebnis:  Funktion

===================================================

Aufbau eine C/C++-Programms:

Einsprungpunkt ist main:

-- In main können weitere Unterprogramme // Funktionen aufgerufen werden.

-- Der Name eines Unterprogramms muss bekannt sein:

   Jede Datei wird EINMAL von oben nach unten gelesen // übersetzt.


======================================================

Logische Operatoren:

Verknüpfung von Bedingungen:  

Logisches UND:    &&

Logisches ODER:   ||

Logisches NOT:    !      false ==> true // true ==> false


Vergleich:

Gleichheit:  ==

( das einfache = ist auf Grund der Wertzuweisung vergeben // a = 123; ) 

Ungleichheit:  !=


Operatoren   VORRANG:  

Ist in einer Vorrang-Tabelle festgelegt.

Nebenbemerkung:

Was sind & und | ??? 

Das sind binäre Verknüpfungen.

======================================================

Binäre Verknüpfungen:

Haben mit Bit-Masken zu tun:

0101
0100

Binär UND verknüpft:  Ist Operator &

0100

Binär ODER verknüpft: Ist Operator |

0101

======================================================

Wiederholungsanweisung:

-- for
-- while
-- do while

======================================================

Frage: Felder und falscher Index

a) KEINE Überprüfung des Index

b) Es kommt zu einem Absturz bzw. zu einem undefinierten Verhalten des Programms.

======================================================

Rest bei einer Division:

Operator %:   Modulo - Operator

======================================================

C++ // Prozeduralen Anteil  // C 

======================================================

2 Divisionen:

a) Ganzzahlige Division
b) Gleitpunkt Division

======================================================
Prozeduraler Anteil von C++
======================================================

Ausgabe:

std::cout: Stellvertreter einer Konsole.

Für elementare Variablen (int, float, ...) ist der << Operator vordefiniert.

Für Klassen kann ich den << Operator selbst implementieren.



Beispiel:

Time jetzt;

std::cout << jetzt;

Operator: << 

Grundlagen des << Operators für die Ausgabe eines Objekts

1. Operand: std::cout Typ: class ostream
2. Operand: jetzt     Typ: class Time

Diese Betrachtung geht nur als "globale" Funktion // Überladen des Operators:

Erster Ansatz:

void operator << (std::ostream os, Time right);

Fast richtig, aber:

Der erste Parameter muss eine ADRESSE eines Objekts sein -- d.h.: keine KOPIE

Besser:

void operator << (std::ostream& os, Time right);

Das & nach dem Typ std::ostream bedeutet, dass das Objekt (Konsole) durch eine
Adresse übergeben wird (keine Kopie).


Voreinstellung für Parameter // Stellvertreter:
     Es handelt sich um eine KOPIE
     des Arguments beim Aufruf !

Von dem Stellvertreter des Konsole (std::cout) darf / kann man keine KOPIE anlegen.




======================================================

Grundlagen des << Operators für die binäre Verarbeitung:

Noch ein Beispiel:

int n = 57;

Binär:

11 1001

RECHTS:

1 * 2 hoch 0 + 0 * 2 hoch 1 + 0 * 2 hoch 2 + 1 * 2 hoch 3 + 1 * 2 hoch 4 + 1 * 2 hoch 5 = 

1          + 0            + 0            + 8 +          16 +           * 32 = 57

Begriff:  2-er Komplement // Zweierkomplement


Bit-Verarbeitung:   Shift-Operationen:

int n = 13;  

Binar:  1101 

n = n << 1;

1101  wird zu 11010   // rechts wird eine Null reingezogen 

n wird zu 26

Auch: 

n = n << 2;

110100   == 52

===============================================

Besonderheit des ++ Operators (gilt auch für --):

Es gibt diesen Operator ZWEIMAL:

a) als Prefix-Operator:  ++ n;

b) als Postfix-Operator: n ++;

Was ist der Unterschied:

a) In einer Stand-Alone Anweisung:

++n;

oder 

n++;

KEINER !!!!!!!!!

b) In einer Wertzuweisung:

i) 	m = ++n;   // Prefix-Variante

    Hier wird ZUERST n INKREMENTIERT, und dann das Ergebnis an
    m zugewiesen.

ii) m = n++;   // Postfix-Variante:

    Hier wird ZUERST n an m zugewiesen -- und danach n inkrementiert.


=================================================================

Namenraum:

Deklaration:

namespace Variant_Product {

	void tueWasWichtiges() {

		std::cout << "Dies ist meine Realisierung" << std::endl;
	}
}

Ist von Interesse, wenn ich 

eine Funktion // eine Klasse 

in der Realisierung aufteilen möchte (Produkt-Betrieb, Test-Betrieb, ...)

--------------------------

Es gibt einen Namensraum, der für uns Anwender nicht zulässig ist:

namespace std   <====== Reserviert für C++ Standard-Klassen, Objekte, Funktion

                Reserviert für die C++ Standard-Bibliothek

=========================================================

Frage bzw. Empfehlung:

Go for 

    std::cout << n;

ODER

	using namespace std;
    ...
    cout << n;

Antwort: Go for 1. Variante:

Nachteil der 2. Variante:

Mit der using Anweisung bzgl. des Namensraums std

wird eine "sehr große Türe" geöffnet.


========================================================

== OO an einem realen Beispiel: Klasse std::string

